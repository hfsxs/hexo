---
title: Python函数
categories:
  - 工作
tags:
  - Linux
  - Python
  - 编程语言
  - 云计算
date: 2023-02-15 21:05:32
---

函数，可重复调用的具有某种特定功能的代码块，通过调用即可实现其功能，面向对象编程中也被称为方法。函数分为内置函数与自定义函数两类：内置函数，Python库自带的已经定义好的函数，直接调用即可，如input、print、max等；自定义函数，Python无法提供的对应各自业务需求的需要开发的函数。函数的引入使得程序更加模块化，不再需要编写大量的重复代码

# 1.函数定义

定义函数，即创建函数，由def关键字实现，语法格式为：

def 函数名(参数列表):
    函数体
    return [返回值]

- def，用于定义函数的关键字，其后为函数标识符和圆括号()，最后的“:”代表函数的起始
- 函数名，即为符合Python语法的标识符，建议以能够体现出函数的功能来命名
- 参数，即需要函数加工运算的一个或多个的初始输入数据，多个参数以“,”隔离，且参数值和参数名称是按函数声明中定义的顺序进行匹配，也可没有参数
- 函数体，即用于实现某种功能的代码块，须进行缩进。Python编码规范建议一个函数只做一件事，函数体建议不超过20行，否则说明这个函数不止做了一件事情，应该将之拆分为更小的函数，或调用其他函数来实现部分功能
- return，用于设置函数的返回值，表示函数的结束，可选参数，即返回值视具体情况而定是否设置，无return语句表示返回None

    def my_function():
        print("Hello world")

# 2.函数调用

函数定义之后即可进行调用，调用方式为：函数名+(参数列表)

    def my_function():
        print("Hello world")

    # 调用函数my_function 
    my_function()

# 3.函数参数

定义函数时其参数就被确定下来，函数的接口也就固定了，调用函数只需要知道如何传递正确的参数，以及函数将返回什么样的值即可，从而使得函数内部的复杂逻辑被封装起来，调用者无需了解。也即是说，参数决定了函数的调用方式

## 3.1 位置参数

位置参数，也称必传参数、顺序参数，是Python最常见的参数传递方式，调用时必须按照函数定义时参数的顺序，依次传递参数的值，且一一对应，个数不多不少，否则将出现语法错误

    >>> def add(a,b):
    ...     return a+b
    ... 
    >>> add(1,2)
    3
    >>> 

## 3.2 默认参数

函数定义时，可为参数指定默认值，这个参数就被称为默认参数，而不再是位置参数了。调用函数时，若没有传递该参数的值就将使用默认值，也可给默认参数传递自定义的值。默认参数简化了函数的调用，在为最常用的情况提供简便调用的同时，也可在特殊情况传递新的值

    >>> def sq(x,n = 2):
    ...     return x**n
    ... 
    >>> sq(3)
    9
    >>> sq(3,3)
    27
    >>>

- 注：默认参数必须定义在位置参数后面，且尽量指向不可变的对象，如整型、字符串、元组，可变对象如列表、字典由于本身就是指向变量的地址，则调用时将会更改其内部元素的数值

## 3.3 关键字参数

调用函数时，使用参数的名称和相应的值来传递参数，这样明确指定参数的值即无需依赖位置，从而可以改变传递参数的顺序，还可以使用默认参数只传递部分参数而不是全部

    >>> def info(name,age):
    ...     print("Name is",name)
    ...     print("Age is",age)
    ... 

    >>> info(age = 15,name = 'LiLei')
    Name is LiLei
    Age is 15
    >>> 

## 3.4 不定长参数

不定长参数表示函数接受任意数量的位置参数，作为元组或字典进行传递，通过在参数名前加上“ * ”定义，即“ *args ”或“ **kwargs ”

### 3.4.1 *args

一个星号的不定长参数表示接收任意参数，调用时会将实际参数作为元组传入形式参数，若参数是列表则会将整个列表当做一个参数传入

    >>> def add(*num):
    ...     total = 0
    ...     for n in num:
    ...         total +=n
    ...     return total
    ... 

    >>> add(1,2,3,4)
    10

### 3.4.2 **kwargs

两个星的不定长参数表示接受任意数量的键值对作为参数，调用的时会将实际参数作为字典传入形式参数

    >>> def info(**stu):
    ...     for k,v in stu.items():
    ...         print(k,":",v)
    ... 

    >>> info(name="Lilei",age=15,city="Beijing")
    name : Lilei
    age : 15
    city : Beijing


- 注：不定长参数必须定义在所有位置参数和默认参数后面

# 4.变量作用域

变量作用域是指变量的有效范围，即变量的访问权限，取决变量所定义的位置，两种最基本的变量作用域为全局作用域和局部作用域：全局作用域变量定义在函数外部，可在整个程序范围内调用；局部作用域变量定义在函数内部，只能在其被声明的函数内部访问，调用函数时局部变量都将被加入到作用域中

    # 定义全局变量total
    >>> total = 0
    >>> def plus(m,n):
            # 定义局部变量total
    ...     total = m + n
    ...     print("函数内部变量total=",total)
    ...     return total
    ... 
    >>> plus(10,20)
    函数内部变量total= 30
    30
    >>> print("函数全局变量total=",total)
    函数全局变量total= 0

# 5.回调函数

回调函数，即将函数作为参数的函数，也就是说其参数是另一个函数，用于降低函数调用之间的耦合性，适用于事件处理、异步编程、定时器与事件循环、钩子函数等场景

    >>> def area(r):
    ...     circle = 3.14 * r * r
    ...     return circle
    ... 
    >>> area(3)
    28.259999999999998

    >>> def r_circle(a):
    ...     r = a * 2
    ...     return r
    ... 
    >>> r_circle(area(3))
    56.519999999999996

# 6.递归函数

递归函数，即函数体内调用其自身的函数，每次递归都会将原始问题分解为规模较小的子问题，如此反复执行，直到达到为防止无限循环而设置的终止条件，也即是原始问题的解决方案。理论上，所有的递归函数都可以写为循环的方式，但循环的逻辑不如递归简单而清晰。需要注意的是，递归函数可能会导致栈溢出，建议深度不超过100层

    # 计算1到100的和，相比起循环方式，递归函数的语意显然更为简洁
    >>> def sum_num(n):
    ...     if n <= 0:
    ...         return 0
    ...     return n+sum_num(n-1)
    ... 
    >>> sum_num(100)
    5050

# 7.函数式编程

函数式编程，即将计算作为纯函数数据处理的编程范式，并尽可能避免或最小化可变状态和副作用，也就是只依赖于输入参数并返回输出结果，而避免出现可变状态和副作用。纯函数通常易于测试、可组合和并发执行，使得代码更具可读性、可维护性和可重用性，编程过程中可进行尝试

## 7.1 匿名函数

匿名函数，Anonymous functions，即无需用def关键字这样标准的显式地定义的函数，而是由Lambda关键字创建。lambda函数是Python语言用于快速地定义一次性的、小型的、功能简单的函数，即用即删，非常轻量化，通常搭配内置函数

### 7.1.1 语法格式

    lambda 参数列表: 表达式

- lambda函数的函数体只是一个表达式，而非代码块，相对简单，因此只能封装有限的逻辑
- lambda函数的输入即为参数列表的值，不能写return，返回值即为表达式的计算值
- lambda函数有自己独立的命名空间，且不能访问自由参数列表之外或全局命名空间的参数

### 7.1.2 定义匿名函数

    >>> area = lambda l,w: l * w

### 7.1.3 调用匿名函数

    >>> area(2,5)
    10

## 7.2 推导式

Python语言的推导式用于从数据序列构建另一个新的数据序列，可快速生成容器类型的数据结构，如列表、字典、集合等

### 7.2.1 列表推导式

语法格式：
    [表达式 for 变量 in 序列] 或 [表达式 for in 序列 if 条件]

- 表达式，列表生成元素的表达式，可以是有返回值的函数
- for语句，迭代列表，并将变量传入表达式
- if语句，过滤列表中不符合条件的值
- 序列，列表、字典、集合和元组等容器型数据结构

---------

    # 列表range(1,10)执行for循环，并将每个元素带入表达式x*x以生成新列表
    >>> list = [x*x for x in range(1,10)]
    >>> print(list)
    [1, 4, 9, 16, 25, 36, 49, 64, 81]
    # 上述推导式新增循环条件，即只对能被2整除的元素进行循环
    >>> [x * x for x in range(1,11) if x % 2 ==0]
    [4, 16, 36, 64, 100]
    # 多重循环，即同时循环x、y两个变量，循环序列为字符串
    >>> [x + y for x in '123' for y in 'abc']
    ['1a', '1b', '1c', '2a', '2b', '2c', '3a', '3b', '3c']
    # 元组型、集合型数据列表推导式的结果仍然是列表型
    >>> num1 = (1,2,3)
    >>> num2 = {1,2,3}
    >>> [x + y for x in num1 for y in num2]
    [2, 3, 4, 3, 4, 5, 4, 5, 6]
    # 字典stu进行列表推导式，即将字典的Value转换为列表
    >>> stu = {'name': 'Lilei','age': 15,'no': 10000}
    >>> [stu[key] for key in stu]
    ['Lilei', 15, 10000]
 
### 7.2.2 字典推导式

字典推导式的语法格式基本与列表推导式一致，即是将其他类型的容器数据结构转换为字典类型


    >>> {x: x**2 for x in (1,2,3)}
    {1: 1, 2: 4, 3: 9}
    
    # 元组stu执行for循环，并将每个元素的值作为字典推导式的Key，每个元素的长度作为字典推导式的Value
    >>> stu = ("Lilei","John","Bob")
    >>> print(stu)
    >>> {'Lilei': 5, 'John': 4, 'Bob': 3}
 
 ### 7.2.3 集合推导式

集合推导式的语法格式基本与列表推导式一致，即是将其他类型的容器数据结构转换为集合类型

    # 由于集合是无序的数据类型，所以字典推导式的结果随机排布
    >>> str = "Python"
    >>> {ch for ch in str}
    {'n', 'P', 'y', 'o', 'h', 't'}

- 注：元组没有推导式，可用类型转换函数tuple()快速生成，如tuple(x for x in range(1,10))

## 7.3 迭代器

迭代器，Python语言可被标记遍历位置的可迭代对象，是一种访问集合元素的方式，表示一连串的元素流对象。其工作流程是从第一个元素开始不断地被next()函数调用并返回下一个元素，直到没有元素时抛出StopIteration错误。迭代器可用for语句循环遍历，整个遍历过程被迭代的元素流有序序列的长度都不被知晓，不像是列表或元组那样一次性将所有元素加载到内存，而是通过next()函数动态地返回下一次将要处理的数据，因此将会节省不少的内存和空间。迭代器由两个方法组成，即iter()和next()，前者用于创建迭代器，后者用于循环迭代器

总之，迭代器可用于遍历可迭代对象，如列表、元组等数据类型，但可由next()方法动态调用而非一次性加载所有元素到内存，所以性能较优

    >>> list = [1,2,3,4]
    >>> it = iter(list)
    >>> for x in it:
    ...     print(x)
    ... 
    1
    2
    3
    4

## 7.4 生成器

生成器，Python语言快速创建迭代器的机制，使用关键字yield定义，写法类似于函数，但不像普通函数用return关键字返回某个值以供调用并结束程序，而是执行yield语句返回迭代器对象，并保存当前位置，下次执行next()方法或for循环时从当前位置继续运行。生成器实质上是一种特殊的迭代器，具有迭代器的性质，即循环计算可迭代对象的元素值而非一次性加载，且自动实现迭代器的功能而不必再调用iter()和next()方法

### 7.4.1 创建生成器

    >>> def countdown(n):
    ...     while n > 0:
                # yield关键字标识该函数为生成器函数
    ...         yield n
    ...         n -= 1
    ...
    # 创建生成器对象
    >>> gen = countdown(10)
    # 通过next()方法迭代生成器对象，每次调用都从上次的位置开始
    >> print(next(gen))
    10
    >>> print(next(gen))
    9
    >>> print(next(gen))
    8
    >>> print(next(gen))
    5
    # 通过for循环遍历生成器对象，开始位置为上次的迭代位置，直到全部遍历为止
    >>> for num in gen:
    ...     print(num)
    ... 
    4
    3
    2
    1

### 7.4.2 生成器表达式

功能简单的生成器可写成简洁的表达式，语法类似于推导式，且比推导式更为节省内存

    >>> gen = (i*i for i in range(5))
    >>> next(gen)
    0
    >>> next(gen)
    1
    >>> next(gen)
    4
    >>> for i in gen:
    ...     print(i)
    ... 
    9
    16

## 7.5 装饰器

装饰器，Python语言用于为已经存在的函数或类动态地增加额外的功能，且不改变原函数或类的代码，其参数是被装饰的函数或类，返回值为带有装饰功能的函数。装饰器适用于切面需求的场景，如日志、缓存、性能测试、事务处理及权限校验等，以抽离大量与函数功能本身无关的重复代码并继续重用，简化程序开发流程，使得代码更具健壮性

### 7.5.1 装饰器定义与调用

装饰器函数通常以@符号为标识，并置于要修饰的函数或类之前


    # 定义函数logs()，其参数为函数func，返回值为函数wrapper，函数具体功能为：输出函数logs()的参数（其参数是函数，并输出函数名）
    >>> def logs(func):
    ...     def wrapper(*args,**kwargs):
    ...         print(f"Calling function: {func.__name__}")
    ...         return func(*args,**kwargs)
    ...     return wrapper
    ... 
    # 调用函数logs()作为装饰函数，用于装饰函数add()
    >>> @logs
    ... def add(a,b):
    ...     return a + b
    ... 
    >>> add(2,3)
    Calling function: add
    5

- logs()作为装饰器函数用于输出功能函数add()的函数名，是装饰器函数日志功能场景的实现。当然，功能函数本身也能实现这个效果，但若多个功能函数（如减法乘法除法函数等）都需要这一功能时，每个功能函数就都需再增加重复的代码，装饰器则只需直接@引用logs()函数即可，显得更加简洁与清晰，同时将功能函数与日志记录分离，逻辑性更强

### 7.5.2 带参数的装饰器

普通的不带参数的装饰器其实定义了两层函数，如logs()最外层为装饰器本身，内层wrapper()函数为装饰器的返回函数，带参数的装饰器即是在此基础上再定义一层函数用于接收参数

    >>> def limit(max_times):
    ...     def logs(func):
    ...         def wrapper(*args,**kwargs):
    ...             if wrapper.max_time < max_times:
    ...                 result = func(*args,**kwargs)
    ...                 wrapper.max_time +=1
    ...                 print(f"Calling function: {func.__name__}")
    ...                 return result
    ...             else:
    ...                 print(f"函数 '{func.__name__}' 已达到最大执行次数.")
    ...                 return None
    ...         wrapper.max_time = 0
    ...         return wrapper
    ...     return logs
    ... 
    ...
    >>> @limit(3)
    ... def add(a,b):
    ...     return a + b
    ... 
    ...
    >>> add(1,2)
    Calling function: add
    3
    >>> add(1,2)
    Calling function: add
    3
    >>> add(1,2)
    Calling function: add
    3
    >>> add(1,2)
    函数 'add' 已达到最大执行次数.

### 7.5.3 类装饰器

装饰器也可由类构建

    >>> class RecordTime(object):
    ...     def __init__(self,func):
    ...         self._func = func
    ...     def __call__(self):
    ...         start_time = time.time()
    ...         self._func()
    ...         end_time = time.time()
    ...         print('spend is {}'.format(end_time - start_time))
    ... 
    >>> @RecordTime
    ... def func():
    ...     print('func...')
    ...     time.sleep(3)
    ... 
    >>> func()
    func...
    spend is 3.000955820083618