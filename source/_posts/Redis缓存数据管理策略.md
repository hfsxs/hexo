---
title: Redis缓存数据管理策略
categories:
  - 工作
tags:
  - Linux
  - Redis
  - NoSQL
  - 缓存
  - 云计算
date: 2024-07-18 10:48:39
---

Redis通常用于高并发场景的缓存层，以减轻频繁数据库读写操所造成的非常耗时的磁盘IO压力，工作机制为：将即时性和数据一致性要求不高而访问量又特别巨大的热点数据（如电商系统的商品列表等）加载到处理速度更快的Redis内存数据库，直接供应用程序调用而不必再经过需要磁盘IO的数据库。若所调用的数据不存在，再到数据库去查询，并将之写入到Redis。同时，数据库有更新操作也应及时更新到Redis，以免造成数据不一致的问题。这样，就减少了磁盘IO的操作，提高了系统的整体性能与响应速度，由此改善了用户体验

Redis内存数据库的特性决定了不是所有数据都能进行缓存，所以在缓存层设计之初就要确认缓存数据及其读写、更新方式，以保障缓存与数据源的一致性。有鉴于此，Redis引入了一系列缓存策略，以便于快速有效地管理缓存数据

# 1.缓存数据读写策略

## 1.1 Cache-Aside

Cache-Aside，即旁路缓存，即将缓存作为独立的存储层，工作机制为：应用程序读取数据先查询Redis，若未命中则从数据库读取，再将数据写入Redis；写操作则是先更新数据库，再依据设置的策略更新或失效相应的缓存数据，以保持数据的一致性。该策略实现简单，灵活性高，数据一致性高，应用较为广泛，适用于读请求较多的场景。但会增加业务逻辑的复杂性，因为缓存数据的更新和失效都由其负责

## 1.2 Read/Write Through

Read/Write Through，即读写穿透，即将缓存与数据库紧密结合，读写操作都通过缓存层操作，工作机制为：应用程序读取数据只通过Redis，若未命中则由Redis负责从数据库读取数据并进行缓存；写入操作由应用程序写入Redis，再由Redis同步更新到数据库。该策略对应用层透明，无需关注缓存细节，数据一致性高。效率较高。但实现复杂，还会影响Redis性能，应用较少

## 1.3 Write-Behind Caching

Write-Behind Caching，即异步写入，类似于读写穿透策略，都是由缓存复杂缓存层和数据库的读写，不同之处在于该策略不是同步更新缓存和数据库，而是只更新缓存，以异步批量方式更新数据库，工作机制为：读取机制与读写穿透策略一致，写操作则写入Redis后立即返回给应用程序，此后再定期或特定条件触发下将缓存数据批量同步到数据库，再依据设置的策略更新或失效相应的缓存数据，以保持数据的一致性。该策略写操作性能高，但数据丢失风险高，数据一致性较弱，适用于数据经常变化且数据一致性要求不高的场景，如浏览量、点赞量等

# 2.缓存数据生成策略

## 2.1 预加载

缓存预加载，又称缓存预热，是程序启动或缓存失效之后主动将热点数据加载到缓存的策略，即请求到达之前热点数据已存在于缓存之中，缺点就是需要提前预测热点数据，若是预测不准则会造成资源浪费

## 2.2 定期生成

定期生成策略即每隔⼀定的周期 (如每日/周/⽉) 对于访问的数据频次进⾏统计（如通过脚本的定时任务执行触发），从中挑选出访问频次最⾼的前N%数据加载到缓存以供调用，如搜索引擎的热点词数据。该策略实现简单，过程可控，排查问题也较为方便，但实时性不够，如突发性事件，很可能出现一个周期内统计不到而被忽略，下个周期又过于集中而造成冲击

## 2.3 实时生成

实时生成策略即先设置缓存容量的上限（通过Redis配置⽂件的maxmemory参数设定），再经过一段时间的数据库交互而达到动态平衡状态，Redis的key逐渐就变成了热点数据。该策略需要考虑项目的综合情况，如项目规模和系统资源、Redis的持久化策略、数据淘汰策略及内存交换等因素，实时监控Redis性能以便根据实际需求进行调整和优化

# 3.缓存数据过期策略

Redis所存储的缓存数据通常都有其有效期，以确保缓存数据保持在最新状态，避免提供过时的数据，也消除了数据持续积累造成的内存耗尽。Redis过期策略即用于管理与清除过期数据，以释放内存、优化缓存管理及避免数据不一致问题，使得保持系统在最佳状态，确保系统的高效运行和稳定性。Redis缓存数据失效策略主要分为三种，即定时删除、惰性删除和内存淘汰

## 3.1 定时清除

定时删除，Expired by Time，Redis最为常用的过期策略，即为每个Key创建用于监控其过期时间定时器，并于预定过期时间自动删除。该策略及时性和数据一致性较强，但大量失效数据的清除操作将会加剧CPU负载，每个key的附加定时器也会增加资源的消耗

## 3.2 惰性清除

惰性删除，Expired by Access，按需清除，即Redis仅在访问key时对其进行过期状态检查，若已过期则进行清除。该策略实现简单，易于理解和维护，也不会影响性能和浪费资源，但存在一定的延迟，过期数据存在堆积的风险，从而影响数据一致性和用户体验，可配合定期清除策略使用

## 3.3 定期清除

定期删除，Expired by Sampling，即定期循环扫描一部分设置了过期策略的Key以便于及时进行清除，还可设置过期数据的占比，并依此为依据进行循环扫描与清除。该策略灵活性较强，也不存在大量删除操作带来的性能压力，但及时性不好，很可能导致部分过期数据由于未被扫描到而产生堆积，从而影响数据一致性，可配合惰性清除策略使用

## 4.缓存数据内存淘汰策略

Redis服务器内存不足以容纳新的数据时，将会根据预设的规则策略删除一些数据以释放空间。这就是内存淘汰策略，建议依据实际应用场景和需求进行选择

## 4.1 LRU

LRU，Least Recently Used，最近最少使用，即从数据集中挑选最近最少被使用的数据进行淘汰，判断依据是访问频率和时间

## 4.2 LFU

LFU，Least Frequently Used，最近最不常使用，类似于LRU，即从数据集中挑选最不经常使用的数据进行淘汰，只通过访问频率进行判断

## 4.3 TTL

TTL，Time To Live，生存时间，即从已设置过期策略的数据集中选出剩余生存时间最短的数据进行淘汰

## 4.4 Random

Random，随机清除策略，分为两种，allkeys-random和volatile-random，前者从全部数据集随机淘汰，后者则从已设置过期策略的数据集随机淘汰

# 5.缓存数据失效场景

Redis实际生产场景中，巨大的并发量和不合理的管理策略都可能引发缓存失效的问题，从而使得大量请求回源数据库，导致数据库服务器资源被占满，甚至引发数据库宕机的严重故障。缓存数据失效的具体场景分为三种，即缓存穿透、雪崩和缓存击穿

## 5.1 缓存穿透

缓存穿透，即客户端请求到达时Redis并没有所要访问的数据（未命中），继续访问数据库读取数据（回源）时也没有数据，后续的这种请求也将重复此过程，将会给数据库带来非常大的压力。该场景的根本原因是客户端访问了并不存在的资源，解决方案为：

- 缓存空值，即将不存在的资源也写入Redis，但其值设为null（key=-1000，value=null）。这样就由Redis直接返回给客户端一个无效的空值，避免了回源到数据库造成的压力，实现简单，但将会导致额外的资源消耗

- 权限设置，即通过对Redis的实时监控对命中率下降问题进行排查，然后对访问数据进行权限控制，如设置黑名单、接口校验、访问拦截等等，直接不允许这些请求到达缓存和数据库

- 设置布隆过滤器，即以BitMap作为布隆过滤器，将目前所有可以访问到的资源通过简单的映射关系（哈希计算）放入其中，请求先经过布隆过滤器的判断，若存在则放行，否则直接拦截，但实现上较为复杂，还存在误判的可能

## 5.2 缓存雪崩

缓存雪崩，即大量缓存数据同一时间集中过期或缓存服务器宕机，大量请求回源数据库，给数据库服务器造成巨大压力，甚至引发数据库宕机的灾难。该场景的根本原因是缓存数据集中过期，解决方案为：

- 构建高可用缓存集群，部署Redis Cluster或哨兵模式集群，确保缓存系统的高可用性，并进行实时监控，以提高缓存层的稳定性和可用性，但将会增加系统复杂度和维护成本

- 构建多级缓存，Redis缓存层之上再增加一层本地缓存，如Nginx/Guava/Spring/JVM缓存，不同层使用不同的缓存，即请求先访问本地缓存，若未命中再访问Redis，但将会增加系统复杂度，还可能带来数据一致性问题

- 均匀分布过期时间，即设置缓存数据过期时间时加入一个随机值，避免大量缓存同时过期，简单有效，易于实现，但可能会发生缓存不一致的问题

- 配置熔断降级机制，即检测到缓存服务不可用时，暂时屏蔽部分非核心功能，只提供最基础服务，类似于Hystrix熔断框架，防止核心功能的崩溃，但会暂时降低用户体验

## 5.3 缓存击穿

缓存击穿，即特定的高频热点Key在缓存过期的一刻同时有大量的请求到达，发现缓存过期之后同时回源数据库，导致数据库瞬间压力剧增，甚至引发数据库宕机。该场景根本原因是热点数据的过期，解决方案为：

- 设置互斥锁，即只有一个到达Redis且未命中的请求获取互斥锁，其余的请求都处于等待状态，直到互斥锁的请求回源数据库并将数据写入Redis之后，再从Redis读取数据。简单有效，避免了大量请求回源数据库的压力，但可能会导致某些请求的等待时间较长

- 设置逻辑过期，即热点数据不设置过期时间，而是通过额外的业务逻辑定期异步更新，但实现复杂，且数据一致性也不强

---------

# 参考文档

- https://blog.csdn.net/chenjiap/article/details/131630981
- https://blog.csdn.net/CYK_byte/article/details/133029259
- https://blog.csdn.net/unravel_tom/article/details/140105493