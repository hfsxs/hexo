---
title: Redis数据持久化详解
categories:
  - 工作
tags:
  - Linux
  - Redis
  - NoSQL
  - 缓存
  - 云计算
date: 2024-07-15 10:16:20
---

Redis是基于内存的NoSQL数据库，内存操作带来的优势是性能极高，但缺点就是服务关闭或主机宕机之后数据将会丢失。Redis持久化机制即是将内存数据写入到硬盘保存到文件，服务或主机重启之后再进行加载并将数据恢复到内存，从而避免数据的意外丢失。Redis数据持久化实现技术分为两种，即RDB和AOF

# 1.RDB方式

RDB，Redis DataBase，内存快照，默认开启的持久化方式，即将内存某一时刻的数据快照全量写入到指定的rdb文件，服务或主机重启自动读取该文件，并将数据加载到内存，恢复到之前的数据库状态

## 1.1 执行方式

RDB持久化的执行方式有三种，即手动save命令、手动bgsave命令和自动触发命令

### 1.1.1 save命令

redis-cli客户端执行save命令即可立即进行一次持久化保存，期间会阻塞redis-server进程，即在此期间Redis不能处理任何读写请求，无法对外提供服务，直到持久化过程完毕

### 1.1.2 bgsave命令

redis-cli客户端执行bgsave（background save）命令即可立即进行一次持久化保存，不同于save命令的是，bgsave命令使主进程redis-server生成一个子进程，由该子进程在后台完成持久化过程，并不会阻塞主进程对客户端读写请求的处理

### 1.1.3 自动触发

自动触发本质仍是bgsave命令的执行，但通过配置文件的相应设置，由Redis根据设置信息自动调用bgsave命令执行持久化过程

## 1.2 工作原理

Redis基于Linux系统写时复制（COW，即Copy On Write）机制实现RDB持久化，即Redis主进程redis-server由fork出来的子进程bgsave以异步方式，将继承自父进程的内存全量数据copy到磁盘的RDB临时文件，copy结束后再将该文件重命名为dump.rdb以替换掉原来的同名文件。在此过程中，redis-server主进程仍然可以处理写请求，并将数据修改的物理块基于写时复制技术copy出一个副本写入到不与子进程bgsave共享的内存区域，直到子进程的内存全量数据copy结束后再将此副本数据copy到RDB临时文件

## 1.3 工作流程

- 1.redis客户端执行bgsave命令或自动触发bgsave命令

- 2.主进程判断当前是否已经存在正在执行的子进程，若存在则直接返回

- 3.若当前不存在正在执行的子进程，则fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作

- 4.子进程将数据写入到临时的rdb文件，直到快照数据写入完成后再替换旧的rdb文件

- 5.同时发送信号给主进程，通知主进程rdb持久化完成，主进程完成相关的统计信息的更新

## 1.4 相关配置

    # 设置RDB和AOF持久化文件的存储目录，默认为Redis安装根目录
    dir "/usr/local/redis/data"
    # 设置RDB持久化文件名，默认为dump.rdb
    dbfilename "dump.rdb"
    # 设置RDB内存快照周期性出发的条件，为空表示关闭RDB持久化，格式为save <seconds> <changes>，表示指定时间内发生了指定次数的写操作，默认值为3600 1 300 100 60 10000，即3600/300/60秒内发生了1/100/10000次写操作
    save 
    # 设置是否启用字符串LZF压缩算法，默认为yes，虽然会消耗系统资源，降低性能，但能大幅降低文件大小，方便保存到磁盘，以及加速主从集群中从节点的数据同步
    rdbcompression yes
    # 设置是否启动数据校验功能，默认为yes，CRC64校验和置于文件末尾，用于抵抗RDB文件的损坏，但性能会受到影响（约10%），追求极致性能的场景可关闭该功能
    rdbchecksum yes
    # 设置主从复制架构是否删除用于同步的从机上的RDB文件，默认为no，但只有从机的RDB和AOF持久化功能都未开启时才能生效
    rdb-del-sync-files no
    # 设置加载RDB文件或进行持久化时是否开启对zipList 、 listPack等数据的全面安全检测，默认为clients，用于降低命令处理时发生系统崩溃的可能，影响性能，可设置值为no，不检测；yes，总是检测，clients，只有当客户端连接时检测
    sanitize-dump-payload
    # 设置快照操作异常（如操作系统用户权限不够、磁盘空间写满等等）时主进程是否禁止写操作，默认为yes，即运行错误的告警，表示数据没有正确地保存到磁盘，故障被解决则将自动允许再次写入
    stop-write-on-bgsave-error yes

## 1.5 适用场景

RDB持久化方式数据压缩与恢复速度快，压缩后的文件远小于内存数据的体积，但由于是非实时备份（即某一时刻的内存快照，快照中的数据将会少与或等于内存数据），所以安全性并不高，可能会导致数据小部分丢失，且fork子进程这种重量级操作频繁执行成本较高，导致实时性不够，无法做到秒级的持久化，降低整体性能。此外，RDB文件时二进制文件，没有可读性。所以，RDB持久化方式适用于数据安全性要求不高的环境，不适合实时持久化场景

# 2.AOF方式

AOF，Append Only File，即将Redis每次写操作都以日志的形式追加记录到AOF文件，服务或内存重启加载该文件并将写操作重新执行，依此恢复到之前的内存数据状态

## 2.1 工作原理

Redis基于写后日志的方式记录AOF日志，即先执行命令将数据写入内存再记录日志，分为三步，即命令追加（append）、文件写入（write）及同步（sync），具体过程为：Redis执行完命令之后，以通讯协议格式将被执行的写命令以纯文本的方式追加到aof_buf缓冲区，最后按照设置的写回策略完成AOF日志的落盘。此外，随着AOF文件越来越大，必然会导致性能的降低，Redis为此引入了Rewrite机制对其进行压缩，即由主线程redis-server所fork的子线程bgrewriteaof对现有AOF文件进行计算（如剔除原文件的读命令、无效命令及过期数据的命令，多条更新命令合并写入），并将计算结果写入临时文件，最后再将该临时文件重命名为原AOF文件以覆盖原文件。在此过程中，主线程仍然可以对外提供读写服务，但将会消耗大量的系统资源，性能会有所下降，所以通常是通过配置文件设置一些触发条件（通常是AOF文件增长到指定的百分比），以规避对性能的影响

## 2.2 工作流程

- 1.Redis将写命令按照通讯协议格式暂时添加到AOF缓冲区aof_buf

- 2.根据设置的数据同步策略，当同步条件满足时将缓冲区数据一次性写入磁盘的AOF文件，以减少磁盘IO次数，提高性能

- 3.当磁盘的AOF文件大小达到了rewrite条件时，redis-server主进程将会fork子进程bgrewriteaof，由该子进程完成rewrite过程

- 4.子进程bgrewriteaof先对该磁盘AOF文件进行rewrite计算，并将计算结果写入到临时文件，全部写入完毕后再重命名该临时文件为磁盘文件的原名称，覆盖原文件

- 5.若rewrite过程中又有写操作命令追加，那么这些数据会暂时写入aof_rewrite_buf缓冲区，直到全部rewrite计算结果写入临时文件后，再将aof_rewrite_buf缓冲区数据写入临时文件，最后为磁盘文件的原名称，覆盖原文件

## 2.3 相关配置

    # 设置是否启用AOF持久化，默认为no
    appendonly yes
    # 设置AOF持久化文件存储目录，默认为Redis安装根目录
    appenddirname
    # 设置AOF持久化文件名，默认为appendonly.aof
    appendfilename appendonly.aof
    # 设置AOF文件同步策略，默认为everysec，可取值为：always，命令执行完毕立即调用fsync()系统函数将缓冲区数据同步到磁盘文件，效率较低，但相对比较安全，不会丢失太多数据，最多即是刚刚执行过的写操作在尚未同步时出现宕机或重启造成数据丢失；no，命令执行完毕将日志写入aof_buf缓冲区后由操作系统调度磁盘同步，Linux系统默认同步周期为30秒，效率较高；everysec，命令执行完毕将日志写入缓冲区后每秒调用fsync()函数完成数据同步，兼顾性能与安全，折中方案
    appendfsync everysec
    # 设置数据重写期间是否不同步数据，默认为no，表示同步，数据量大时将会阻塞主进程对外服务，即存在延迟；yes表示不同步，相当于fsync设为no，存在30秒数据丢失的风险。建议高并发的写操作设为yes，读操作设为no
    no-appendfsync-on-rewrite no
    # 设置数据重写期间是否开启缓存控制，即rewrite计算结果的缓存累计到一定数量（默认为4M）时一次性写入临时文件，完成数据同步，以免由于单次刷盘量过大而引发长时间阻塞
    aof-rewrite-incremental-fsync yes
    # 设置AOF文件的数据不完整（突然宕机的情况最后的数据可能并没有完全同步）时能否启动Redis，yes表示将不完整的数据截断删除后加载，不影响Redis启动；no表示无法启动Redis
    aof-load-turncated yes
    # 设置是否开启AOF文件增加时间戳的显示功能，默认为no，不开启，虽然方便于按照时间对数据进行恢复，但可能会与当前AOF解析器不兼容
    aof-timestamp-enabled no

## 2.4 适用场景

AOF持久化方式数据安全性高，AOF文件可读性高，在了解其结构的情况下可以手动修改或补全，但文件较大，数据恢复速度慢，日志写操作对性能有影响，官方并不推荐纯AOF方式，默认不开启

# 3.混合方式

Redis官方推荐RDB与AOF混合式持久化，以兼容两者的优点，即执行AOF重写时，将当前内存数据以RDB快照方式写入AOF文件的开头，之后的数据再以AOF格式追加到文件的末尾。数据恢复过程与AOF方式一致，只需将appendonly.aof文件存放到Redis的根目录即可自动加载并恢复。这样，AOF文件的开头部分是记录了某一时刻数据集的RDB快照，加快了恢复速度；后续部分是记录了数据集增量修改的AOF日志，降低了数据丢失的风险，缩小了文件体积（因为AOF日志并不是全量日志，而是自持久化开始到持久化结束这段时间发生的增量 AOF日志）。但混合持久化方式适合Redis 4.0之后的版本，此外由于AOF文件添加了RDB格式内容，可读性也随之变差

## 3.1 工作流程

- 1.判断是否开启AOF持久化，若已开启则继续执行后续流程，否则执行加载RDB文件的流程
- 2.判断appendonly.aof文件是否存在，即是否已开启混合持久化方式，文件存在则执行后续流程
- 3.判断AOF文件开头是否为RDB格式, 若是则先加载RDB内容再加载剩余的AOF内容，否则直接以AOF格式加载整个文件

## 3.2 相关配置

    # 设置是否开启混合持久化，默认为yes
    aof-use-rdb-preamble yes

# 4.最佳实践

Redis官方建议基于实际业务出发，若数据丢失不敏感的场景则可关闭持久化，如仅用于缓存的环境。主从复制架构则建议负责写操作的主节点不开启持久化，而开启负责读操作的从节点持久化功能，以最大限度地降低持久化所损耗的IO性能。此外，由于Redis大部分时间都在做读写操作，所以更大的内存和更快的磁盘对其性能的提高非常有帮助，而对CPU的要求并不高

---------

# 参考文档

- https://www.modb.pro/db/126254
- https://www.cnblogs.com/sxy-blog/p/17971886
- https://blog.csdn.net/weixin_67596609/article/details/140417657
- https://blog.csdn.net/weixin_43412762/article/details/134795648